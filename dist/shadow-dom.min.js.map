{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "src\\interfaces\\Document.js",
    "src\\interfaces\\Element.js",
    "src\\interfaces\\Event.js",
    "src\\interfaces\\EventTarget.js",
    "src\\interfaces\\HTMLSlotElement.js",
    "src\\interfaces\\HTMLTableElement.js",
    "src\\interfaces\\HTMLTableRowElement.js",
    "src\\interfaces\\HTMLTableSectionElement.js",
    "src\\interfaces\\Node.js",
    "src\\interfaces\\ShadowRoot.js",
    "src\\main.js",
    "src\\mixins\\ChildNode.js",
    "src\\mixins\\DocumentOrShadowRoot.js",
    "src\\mixins\\NonDocumentTypeChildNode.js",
    "src\\mixins\\NonElementParentNode.js",
    "src\\mixins\\ParentNode.js",
    "src\\mixins\\Slotable.js",
    "src\\patch.js",
    "src\\utils.js"
  ],
  "names": [],
  "mappings": "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",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#interface-document\r\n\r\n[Constructor, Exposed=Window]\r\ninterface Document : Node\r\n\r\n[Exposed=Window]\r\ninterface XMLDocument : Document {};\r\n\r\ndictionary ElementCreationOptions {\r\n  DOMString is;\r\n};\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nexport default class {\r\n\r\n    // TODO: tests\r\n    getElementsByTagName(qualifiedName) {\r\n        const collection = $.native.Document.getElementsByTagName.call(this, qualifiedName);\r\n        const filtered = [];\r\n\r\n        for (let i = 0; i < collection.length; i++) {\r\n            const item = collection[i];\r\n            if (this === item.getRootNode({ composed: false })) {\r\n                filtered.push(item)\r\n            }\r\n        }\r\n\r\n        return filtered;\r\n    }\r\n\r\n    // TODO: tests\r\n    getElementsByTagNameNS(ns, localName) {\r\n        const collection = $.native.Document.getElementsByTagNameNS.call(this, ns, localName);\r\n        const filtered = [];\r\n\r\n        for (let i = 0; i < collection.length; i++) {\r\n            const item = collection[i];\r\n            if (this === item.getRootNode({ composed: false })) {\r\n                filtered.push(item)\r\n            }\r\n        }\r\n\r\n        return filtered;\r\n    }\r\n\r\n    // TODO: tests\r\n    getElementsByClassName(names) {\r\n        const collection = $.native.Document.getElementsByClassName.call(this, name);\r\n        const filtered = [];\r\n\r\n        for (let i = 0; i < collection.length; i++) {\r\n            const item = collection[i];\r\n            if (this === item.getRootNode({ composed: false })) {\r\n                filtered.push(item)\r\n            }\r\n        }\r\n\r\n        return filtered;\r\n    }\r\n\r\n    // [NewObject] Element createElement(DOMString localName, optional ElementCreationOptions options);\r\n    // [NewObject] Element createElementNS(DOMString? namespace, DOMString qualifiedName, optional ElementCreationOptions options);\r\n    // [NewObject] DocumentFragment createDocumentFragment();\r\n    // [NewObject] Text createTextNode(DOMString data);\r\n    // [NewObject] CDATASection createCDATASection(DOMString data);\r\n    // [NewObject] Comment createComment(DOMString data);\r\n    // [NewObject] ProcessingInstruction createProcessingInstruction(DOMString target, DOMString data);\r\n\r\n    // TODO: tests\r\n    importNode(node, deep) {\r\n        if (node.nodeType === Node.DOCUMENT_NODE || node.nodeName === '#shadow-root') {\r\n            throw $.makeError('NotSupportedError');\r\n        }\r\n\r\n        return $.clone(node, this, deep);\r\n    }\r\n\r\n    // [CEReactions, NewObject] Node importNode(Node node, optional boolean deep = false);\r\n    // [CEReactions] Node adoptNode(Node node);\r\n\r\n    // [NewObject] Attr createAttribute(DOMString localName);\r\n    // [NewObject] Attr createAttributeNS(DOMString? namespace, DOMString qualifiedName);\r\n\r\n    // [NewObject] Event createEvent(DOMString interface);\r\n\r\n    // [NewObject] Range createRange();\r\n\r\n    // // NodeFilter.SHOW_ALL = 0xFFFFFFFF\r\n    // [NewObject] NodeIterator createNodeIterator(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null);\r\n    // [NewObject] TreeWalker createTreeWalker(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null);\r\n\r\n}",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#interface-element\r\nhttps://www.w3.org/TR/DOM-Parsing/#extensions-to-the-element-interface\r\n\r\n[Exposed=Window]\r\ninterface Element : Node\r\n\r\ndictionary ShadowRootInit {\r\n  required ShadowRootMode mode;\r\n};\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nimport $ShadowRoot from '../interfaces/ShadowRoot.js';\r\n\r\nfunction updateSlotableName(element, localName, oldValue, value, namespace) {\r\n    // https://dom.spec.whatwg.org/#slotable-name\r\n    if (localName === 'slot' && namespace === null) {\r\n        if (value === oldValue) {\r\n            return;\r\n        }\r\n        if (value === null && oldValue === '') {\r\n            return;\r\n        }\r\n        if (value === '' && oldValue === null) {\r\n            return;\r\n        }\r\n        if (value === null || value === '') {\r\n            $.native.Element.setAttribute.call(element, 'slot', '');\r\n        }\r\n        else {\r\n            $.native.Element.setAttribute.call(element, 'slot', value);\r\n        }\r\n        const assignedSlot = $.shadow(element).assignedSlot;\r\n        if (assignedSlot) {\r\n            $.assignSlotables(assignedSlot);\r\n        }\r\n        $.assignASlot(element);\r\n    }\r\n}\r\n\r\nexport default class {\r\n\r\n    // TODO: Override setAttribute, setAttributeNS, removeAttribute,\r\n    // removeAttributeNS, setAttributeNode, setAttributeNodeNS, \r\n    // and removeAttributeNode to detect slot changes\r\n\r\n    get slot() {\r\n        // The slot attribute must reflect the \"slot\" content attribute.\r\n        return this.getAttribute('slot');\r\n    }\r\n\r\n    // TODO: tests\r\n    set slot(value) {\r\n        updateSlotableName(this, 'slot', this.slot, value, null);\r\n    }\r\n\r\n    attachShadow(init) {\r\n        // https://dom.spec.whatwg.org/#dom-element-attachshadow\r\n        if (!init || (init.mode !== 'open' && init.mode !== 'closed')) {\r\n            throw $.makeError('TypeError');\r\n        }\r\n\r\n        if (this.namespaceURI !== 'http://www.w3.org/1999/xhtml') {\r\n            throw $.makeError('NotSupportedError');\r\n        }\r\n\r\n        switch (this.localName) {\r\n            case \"article\": case \"aside\": case \"blockquote\": case \"body\": \r\n            case \"div\": case \"footer\": case \"h1\": case \"h2\": case \"h3\":\r\n            case \"h4\": case \"h5\": case \"h6\": case \"header\": case \"main\":\r\n            case \"nav\": case \"p\": case \"section\": case \"span\":\r\n                break;\r\n            default:\r\n                if ($.isValidCustomElementName(this.localName)) {\r\n                    break;\r\n                }\r\n                throw $.makeError('NotSupportedError');\r\n        }\r\n\r\n        if (this.shadowRoot) {\r\n            throw $.makeError('InvalidStateError');\r\n        }\r\n\r\n        const shadow = this.ownerDocument.createDocumentFragment();\r\n        \r\n        $.extend(shadow, $ShadowRoot);\r\n\r\n        $.shadow(shadow, {\r\n            host: this,\r\n            mode: init.mode,\r\n            childNodes: []\r\n        });\r\n\r\n        $.shadow(this, {\r\n            shadowRoot: shadow,\r\n            childNodes: $.slice(this.childNodes)\r\n        });\r\n\r\n        const childNodes = $.shadow(this).childNodes;\r\n        for (let i = 0; i < childNodes.length; i++) {\r\n            $.shadow(childNodes[i], {\r\n                parentNode: this\r\n            });\r\n        }\r\n\r\n        $.native.Element.innerHTML.set.call(this, null);\r\n\r\n        return shadow;\r\n    }\r\n\r\n    get shadowRoot() {\r\n        // https://dom.spec.whatwg.org/#dom-element-shadowroot\r\n        \r\n        let shadowRoot = $.shadow(this).shadowRoot;\r\n\r\n        if (!shadowRoot || shadowRoot.mode === 'closed') {\r\n            return null;\r\n        }\r\n\r\n        return shadowRoot;\r\n    }\r\n\r\n    // TODO: tests\r\n    closest(selectors) {\r\n        let element = this;\r\n\r\n        do {\r\n            if (element.matches(selectors)) {\r\n                return element;\r\n            }\r\n        }\r\n        while (element = element.parentElement);\r\n    }\r\n\r\n    // TODO: tests\r\n    getElementsByTagName(qualifiedName) {\r\n        const contextRoot = this.getRootNode({ composed: false });\r\n        const collection = $.native.Element.getElementsByTagName.call(this, qualifiedName);\r\n        const filtered = [];\r\n\r\n        for (let i = 0; i < collection.length; i++) {\r\n            const item = collection[i];\r\n            if (contextRoot === item.getRootNode({ composed: false })) {\r\n                filtered.push(item)\r\n            }\r\n        }\r\n\r\n        return filtered;\r\n    }\r\n\r\n    // TODO: tests\r\n    getElementsByTagNameNS(ns, localName) {\r\n        const contextRoot = this.getRootNode({ composed: false });\r\n        const collection = $.native.Element.getElementsByTagNameNS.call(this, ns, localName);\r\n        const filtered = [];\r\n\r\n        for (let i = 0; i < collection.length; i++) {\r\n            const item = collection[i];\r\n            if (contextRoot === item.getRootNode({ composed: false })) {\r\n                filtered.push(item)\r\n            }\r\n        }\r\n\r\n        return filtered;\r\n    }\r\n\r\n    // TODO: tests\r\n    getElementsByClassName(names) {\r\n        const contextRoot = this.getRootNode({ composed: false });\r\n        const collection = $.native.Element.getElementsByClassName.call(this, name);\r\n        const filtered = [];\r\n\r\n        for (let i = 0; i < collection.length; i++) {\r\n            const item = collection[i];\r\n            if (contextRoot === item.getRootNode({ composed: false })) {\r\n                filtered.push(item)\r\n            }\r\n        }\r\n\r\n        return filtered;\r\n    }\r\n\r\n    // TODO: tests\r\n    insertAdjacentElement(where, element) {\r\n        // https://dom.spec.whatwg.org/#dom-element-insertadjacentelement\r\n        return $.insertAdjacent(this, where, element);\r\n    }\r\n\r\n    // TODO: tests\r\n    insertAdjacentText(where, data) {\r\n        // https://dom.spec.whatwg.org/#dom-element-insertadjacenttext\r\n        const text = this.ownerDocument.createTextNode(data);\r\n        $.insertAdjacent(this, where, text);\r\n        return;\r\n    }\r\n\r\n    // https://w3c.github.io/DOM-Parsing/#extensions-to-the-element-interface\r\n\r\n    // TODO: tests\r\n    get innerHTML() {\r\n        // https://w3c.github.io/DOM-Parsing/#dom-element-innerhtml\r\n        return $.serializeHTMLFragment(this);\r\n    }\r\n\r\n    // TODO: tests\r\n    set innerHTML(value) {\r\n        // https://w3c.github.io/DOM-Parsing/#dom-element-innerhtml\r\n        const fragment = $.parseHTMLFragment(value, this);\r\n        $.replaceAll(fragment, this);\r\n    }\r\n\r\n    // TODO: tests\r\n    get outerHTML() {\r\n        // https://w3c.github.io/DOM-Parsing/#dom-element-outerhtml\r\n        return $.serializeHTMLFragment({ childNodes: [ this ] });\r\n    }\r\n\r\n    // TODO: tests\r\n    set outerHTML(value) {\r\n        // https://w3c.github.io/DOM-Parsing/#dom-element-outerhtml\r\n        let parent = this.parentNode;\r\n        if (parent === null) {\r\n            return;\r\n        }\r\n        if (parent.nodeType === Node.DOCUMENT_NODE) {\r\n            throw $.makeError('NoModificationAllowedError');\r\n        }\r\n        if (parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\r\n            parent = this.ownerDocument.createElement('body');\r\n        }\r\n        const fragment = $.parseHTMLFragment(value, parent);\r\n        $.replace(this, fragment, this.parentNode);\r\n    }\r\n\r\n    // TODO: tests\r\n    insertAdjacentHTML(position, text) {\r\n        // https://w3c.github.io/DOM-Parsing/#dom-element-insertadjacenthtml\r\n        // We aren't going to go exactly by the books for this one.\r\n        const fragment = $.parseHTMLFragment(text, this);\r\n        $.insertAdjacent(this, position, fragment);\r\n    }\r\n\r\n}",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#interface-event\r\n\r\n[Constructor(DOMString type, optional EventInit eventInitDict), Exposed=(Window,Worker)]\r\ninterface Event\r\n\r\ndictionary EventInit {\r\n  boolean bubbles = false;\r\n  boolean cancelable = false;\r\n  boolean composed = false;\r\n};\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nexport default class {\r\n\r\n    // TODO: impl, tests\r\n    constructor(type, init) {\r\n        $.shadow(this).composed = (init && init.composed === true);\r\n    }\r\n\r\n    // TODO: impl, tests\r\n    get target() {\r\n        return null;\r\n    }\r\n\r\n    // TODO: impl, tests\r\n    get currentTarget() {\r\n        return null;\r\n    }\r\n\r\n    // TODO: impl, tests\r\n    composedPath() {\r\n        let composedPath = $.shadow(this).composedPath;\r\n\r\n        if (composedPath) {\r\n            return composedPath.slice();\r\n        }\r\n\r\n        // https://dom.spec.whatwg.org/#dom-event-composedpath\r\n\r\n        // 1. Let composedPath be a new empty list.\r\n        composedPath = $.shadow(this).composedPath = [];\r\n\r\n        // 2. Let currentTarget be context object’s currentTarget attribute value.\r\n        const currentTarget = this.currentTarget;\r\n\r\n        // 3. For each tuple in context object’s path:\r\n        const path = calculatePath(this);\r\n\r\n        if (currentTarget instanceof Window) {\r\n            for (const [ item ] of path) {\r\n                if (item instanceof Node) {\r\n                    if (!$.closedShadowHidden(item, item.getRootNode({ composed: true }))) {\r\n                        composedPath.push(item);\r\n                    }\r\n                }\r\n                else {\r\n                    composedPath.push(item);\r\n                }\r\n            }\r\n        }\r\n        else if (currentTarget instanceof Node) {\r\n            for (const [ item ] of path) {\r\n                if (!$.closedShadowHidden(item, item.getRootNode({ composed: true }))) {\r\n                    composedPath.push(item);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            composedPath.push(...path);\r\n        }\r\n\r\n        // 4. return composedPath.\r\n        return composedPath.slice();\r\n    }\r\n\r\n    get composed() {\r\n        return $.shadow(this).composed;\r\n    }\r\n\r\n}\r\n\r\nfunction calculatePath(event) {\r\n    let path = $.shadow(event).path;\r\n\r\n    if (path) {\r\n        return path;\r\n    }\r\n\r\n    // Starting at step 8:\r\n    // https://dom.spec.whatwg.org/#concept-event-dispatch\r\n\r\n    path = $.shadow(event).path = [];\r\n\r\n    // 8. Let parent be the result of invoking target’s get the parent with event.\r\n    let target = event.target;\r\n    let parent = getTheParent(target, event);\r\n\r\n    // 9. While parent is non-null:\r\n    while (parent !== null) {\r\n        // 1. Let relatedTarget be the result of retargeting event’s relatedTarget\r\n        // against parent if event’s relatedTarget is non-null, and null otherwise.\r\n        let relatedTarget = event.relatedTarget;\r\n        if (relatedTarget !== null) {\r\n            relatedTarget = $.retarget(relatedTarget, parent);\r\n        }\r\n        // 2. If target’s root is a shadow-including inclusive ancestor of parent, then... \r\n        // append (parent, null, relatedTarget) to event’s path.\r\n        const root = target.getRootNode({ composed: false });\r\n        if ($.shadowIncludingInclusiveAncestor(root, parent)) {\r\n            path.push([ parent, null, relatedTarget ]);\r\n        }\r\n        // 3. Otherwise, if parent and relatedTarget are identical, then set parent to null.\r\n        else if (parent === relatedTarget) {\r\n            parent = null;\r\n        }\r\n        // 4. Otherwise, set target to parent and then... \r\n        // append (parent, target, relatedTarget) to event’s path.\r\n        else {\r\n            target = parent;\r\n            path.push([ parent, target, relatedTarget ]);\r\n        }\r\n        // 5. If parent is non-null, then set parent to the result of \r\n        // invoking parent’s get the parent with event.\r\n        if (parent !== null) {\r\n            parent = getTheParent(parent, event);\r\n        }\r\n    }\r\n\r\n    return path;\r\n}\r\n\r\nfunction getTheParent(target, event) {\r\n    // https://dom.spec.whatwg.org/#get-the-parent\r\n    // Each EventTarget object also has an associated get the parent \r\n    // algorithm, which takes an event event, and returns an EventTarget \r\n    // object. Unless specified otherwise it returns null.\r\n\r\n    // A node’s get the parent algorithm, given an event, \r\n    // returns the node’s assigned slot, if node is assigned, \r\n    // and node’s parent otherwise.\r\n\r\n    // A document’s get the parent algorithm, given an event, returns null if event’s \r\n    // type attribute value is \"load\" or document does not have a browsing context, \r\n    // and the document’s associated Window object otherwise.\r\n\r\n    // A shadow root’s get the parent algorithm, given an event, returns null if \r\n    // event’s composed flag is unset and shadow root is the root of event’s \r\n    // path’s first tuple’s item, and shadow root’s host otherwise.\r\n\r\n    if (node instanceof Node) {\r\n        if (node.nodeType === Node.DOCUMENT_NODE) {\r\n            if (event.type === 'load') { // or browsing context?\r\n                return null;\r\n            }\r\n            return document.defaultView;\r\n        }\r\n        else if (node.localName === '#shadow-root') {\r\n            if (!event.composed) {\r\n                const [ item ] = $.shadow(event).path[0];\r\n                if (item.getRootNode() === node) {\r\n                    return null;\r\n                }\r\n            }\r\n            return node.host;\r\n        }\r\n        return node.assignedSlot || node.parentNode;\r\n    }\r\n\r\n    return null;\r\n}",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#interface-eventtarget\r\n\r\n[Exposed=(Window,Worker)]\r\ninterface EventTarget\r\n\r\ncallback interface EventListener {\r\n  void handleEvent(Event event);\r\n};\r\n\r\ndictionary EventListenerOptions {\r\n  boolean capture = false;\r\n};\r\n\r\ndictionary AddEventListenerOptions : EventListenerOptions {\r\n  boolean passive = false;\r\n  boolean once = false;\r\n};\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nexport default function (base) {\r\n\r\n  const native = {\r\n    addEventListener: base.prototype.addEventListener,\r\n    removeEventListener: base.prototype.removeEventListener\r\n  };\r\n\r\n  return class {\r\n\r\n    // TODO: impl, tests\r\n    // void addEventListener(DOMString type, EventListener? callback, optional (AddEventListenerOptions or boolean) options);\r\n\r\n    // TODO: impl, tests\r\n    // void removeEventListener(DOMString type, EventListener? callback, optional (EventListenerOptions or boolean) options);\r\n\r\n  };\r\n\r\n}",
    "/*\r\n\r\nhttps://html.spec.whatwg.org/multipage/scripting.html#the-slot-element\r\n\r\ninterface HTMLSlotElement : HTMLElement\r\n\r\ndictionary AssignedNodesOptions {\r\n    boolean flatten = false;\r\n};\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nexport default class {\r\n\r\n    // TODO: tests\r\n    get name() {\r\n        return this.getAttribute('name');\r\n    }\r\n\r\n    // TODO: tests\r\n    set name(value) {\r\n        this.setAttribute('name', value);\r\n    }\r\n\r\n    // TODO: tests\r\n    assignedNodes(options) {\r\n        if (this.localName !== 'slot') {\r\n            return;\r\n        }\r\n\r\n        // https://html.spec.whatwg.org/multipage/scripting.html#dom-slot-assignednodes\r\n        // The assignedNodes(options) method, when invoked, must run these steps:\r\n\r\n        // 1. If the value of options's flatten member is false, then return this element's assigned nodes.\r\n        if (!options || options.flatten !== true) {\r\n            return $.shadow(this).assignedNodes;\r\n        }\r\n\r\n        // 2. Return the result of finding flattened slotables with this element.\r\n        return $.findFlattenedSlotables(this);    \r\n    }\r\n\r\n}",
    "/*\r\n\r\nhttps://www.w3.org/TR/html5/single-page.html#the-table-element\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nexport default class {\r\n\r\n    deleteCaption() {\r\n        const caption = this.caption;\r\n        if (caption) {\r\n            $.remove(caption, this);\r\n        }\r\n    }\r\n\r\n    deleteTHead() {\r\n        const tHead = this.tHead;\r\n        if (tHead) {\r\n            $.remove(tHead, this);\r\n        }\r\n    }\r\n\r\n    deleteTFoot() {\r\n        const tFoot = this.tFoot;\r\n        if (tFoot) {\r\n            $.remove(tFoot, this);\r\n        }\r\n    }\r\n\r\n    deleteRow(index) {\r\n        // https://www.w3.org/TR/html5/single-page.html#dom-table-deleterow\r\n        if (index === -1) {\r\n            index = this.rows.length - 1;\r\n        }\r\n        if (index < 0 || index >= this.rows.length) {\r\n            throw $.makeError('IndexSizeError');\r\n        }\r\n        this.rows[index].remove();\r\n    }\r\n\r\n}",
    "/*\r\n\r\nhttps://www.w3.org/TR/html5/single-page.html#the-tr-element\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nexport default class {\r\n\r\n    deleteCell(index) {\r\n        // https://www.w3.org/TR/html5/single-page.html#dom-tr-deletecell\r\n        if (index === -1) {\r\n            index = this.cells.length - 1;\r\n        }\r\n        if (index < 0 || index >= this.cells.length) {\r\n            throw $.makeError('IndexSizeError');\r\n        }\r\n        this.cells[index].remove();\r\n    }\r\n\r\n}",
    "/*\r\n\r\nhttps://www.w3.org/TR/html5/single-page.html#the-tbody-element\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nexport default class {\r\n\r\n    deleteRow(index) {\r\n        // https://www.w3.org/TR/html5/single-page.html#dom-tbody-deleterow\r\n        if (index < 0 || index >= this.rows.length) {\r\n            throw $.makeError('IndexSizeError');\r\n        }\r\n        this.rows[index].remove();\r\n    }\r\n\r\n}",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#interface-node\r\n\r\n[Exposed=Window]\r\ninterface Node : EventTarget\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nexport default class {\r\n\r\n    getRootNode(options) {\r\n        // https://dom.spec.whatwg.org/#dom-node-getrootnode\r\n\r\n        const composed = options && (options.composed === true);\r\n\r\n        let root, ancestor;\r\n\r\n        root = ancestor = this;\r\n\r\n        if (!composed) {\r\n            while (ancestor = ancestor.parentNode) {\r\n                root = ancestor;\r\n            }\r\n\r\n            return root;\r\n        }\r\n\r\n        while (ancestor = ancestor.parentNode) {\r\n            root = ancestor;\r\n\r\n            if (root.nodeName === '#shadow-root') {\r\n                root = ancestor = root.host;\r\n            }\r\n        }\r\n\r\n        return root;\r\n    }\r\n\r\n    get parentNode() {\r\n        const parentNode = $.shadow(this).parentNode;\r\n        if (parentNode) {\r\n            return parentNode;\r\n        }\r\n\r\n        return $.native.Node.parentNode.get.call(this);\r\n    }\r\n\r\n    get parentElement() {\r\n        const parentNode = this.parentNode;\r\n        if (parentNode && parentNode.nodeType === Node.ELEMENT_NODE) {\r\n            return parentNode;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    // TODO: tests\r\n    hasChildNodes() {\r\n        const childNodes = $.shadow(this).childNodes;\r\n        if (childNodes) {\r\n            return childNodes.length > 0;\r\n        }\r\n\r\n        return $.native.Node.hasChildNodes.call(this);\r\n    }\r\n\r\n    // TODO: tests\r\n    get childNodes() {\r\n        const childNodes = $.shadow(this).childNodes;\r\n        if (childNodes) {\r\n            return childNodes.slice();\r\n        }\r\n\r\n        return $.native.Node.childNodes.get.call(this);\r\n    }\r\n\r\n    // TODO: tests\r\n    get firstChild() {\r\n        const childNodes = $.shadow(this).childNodes;\r\n        if (childNodes) {\r\n            if (childNodes.length) {\r\n                return childNodes[0];\r\n            }\r\n            return null;\r\n        }\r\n\r\n        return $.native.Node.firstChild.get.call(this);\r\n    }\r\n\r\n    // TODO: tests\r\n    get lastChild() {\r\n        const childNodes = $.shadow(this).childNodes;\r\n        if (childNodes) {\r\n            if (childNodes.length) {\r\n                return childNodes[childNodes.length - 1];\r\n            }\r\n            return null;\r\n        }\r\n\r\n        return $.native.Node.lastChild.get.call(this);\r\n    }\r\n\r\n    // TODO: tests\r\n    get previousSibling() {\r\n        const parentNode = $.shadow(this).parentNode;\r\n        if (parentNode) {\r\n            const childNodes = $.shadow(parentNode).childNodes;\r\n            const siblingIndex = childNodes.indexOf(this) - 1;\r\n            return siblingIndex < 0 ? null : childNodes[siblingIndex];\r\n        }\r\n\r\n        return $.native.Node.previousSibling.get.call(this);\r\n    }\r\n\r\n    // TODO: tests\r\n    get nextSibling() {\r\n        const parentNode = $.shadow(this).parentNode;\r\n        if (parentNode) {\r\n            const childNodes = $.shadow(parentNode).childNodes;\r\n            const siblingIndex = childNodes.indexOf(this) + 1;\r\n            return siblingIndex === childNodes.length ? null : childNodes[siblingIndex];\r\n        }\r\n\r\n        return $.native.Node.nextSibling.get.call(this);\r\n    }\r\n\r\n    // TODO: tests\r\n    get textContent() {\r\n        switch (this.nodeType) {\r\n            case Node.DOCUMENT_FRAGMENT_NODE:\r\n            case Node.ELEMENT_NODE:\r\n                let result = '';\r\n                const childNodes = this.childNodes;\r\n                for (let i = 0; i < childNodes.length; i++) {\r\n                    result += childNodes[i].textContent;\r\n                }\r\n                return result;\r\n            case Node.ATTRIBUTE_NODE:\r\n                return this.value;\r\n            case Node.TEXT_NODE:\r\n            case Node.PROCESSING_INSTRUCTION_NODE:\r\n            case Node.COMMENT_NODE:\r\n                return this.data;\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n\r\n    // TODO: tests\r\n    set textContent(value) {\r\n        switch (this.nodeType) {\r\n            case Node.DOCUMENT_FRAGMENT_NODE:\r\n            case Node.ELEMENT_NODE:\r\n                let node = null;\r\n                if (value !== '') {\r\n                    node = this.ownerDocument.createTextNode(value);\r\n                }\r\n                $.replaceAll(node, this);\r\n                return;\r\n        }\r\n\r\n        return $.native.Node.textContent.set.call(this, value);\r\n    }\r\n\r\n    // TODO: tests\r\n    normalize() {\r\n        // https://dom.spec.whatwg.org/#dom-node-normalize\r\n        // The normalize() method, when invoked, must run these steps \r\n        // for each descendant exclusive Text node node of context object:\r\n        const childNodes = this.childNodes;\r\n        for (let i = 0; i < childNodes.length; i++) {\r\n            let childNode = childNodes[i];\r\n            if (childNode.hasChildNodes()) {\r\n                childNode.normalize();\r\n            }\r\n            else if (childNode.nodeType === Node.TEXT_NODE) {\r\n                let length = childNode.data.length;\r\n                if (length === 0) {\r\n                    $.remove(childNode, this);\r\n                    continue;\r\n                }\r\n                let j;\r\n                for (j = i + 1; j < childNodes.length; j++) {\r\n                    let nextSibling = childNodes[j];\r\n                    if (nextSibling.nodeType !== Node.TEXT_NODE) {\r\n                        break;\r\n                    }\r\n                    childNode.data += nextSibling.data;\r\n                    i++;\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // TODO: tests\r\n    cloneNode(deep) {\r\n        // https://dom.spec.whatwg.org/#dom-node-clonenode\r\n        // The cloneNode(deep) method, when invoked, must run these steps:\r\n\r\n        // 1. If context object is a shadow root, then throw a NotSupportedError.\r\n        if (this.nodeName === '#shadow-root') {\r\n            throw $.makeError('NotSupportedError');\r\n        }\r\n\r\n        // 2. Return a clone of the context object, with the clone children flag set if deep is true.\r\n        return $.clone(this, undefined, deep);\r\n    }\r\n\r\n    // TODO: tests\r\n    isEqualNode(other) {\r\n        // https://dom.spec.whatwg.org/#dom-node-isequalnode\r\n        // https://dom.spec.whatwg.org/#concept-node-equals\r\n        if (!other) {\r\n            return false;\r\n        }\r\n\r\n        if (this.nodeType !== other.nodeType) {\r\n            return false;\r\n        }\r\n\r\n        switch (this.nodeType) {\r\n            case Node.DOCUMENT_TYPE_NODE:\r\n                if (this.name !== other.name ||\r\n                    this.publicId !== other.publicId ||\r\n                    this.systemId !== other.systemId) {\r\n                    return false;\r\n                }\r\n            case Node.ELEMENT_NODE:\r\n                if (this.namespaceURI !== other.namespaceURI ||\r\n                    this.prefix !== other.prefix ||\r\n                    this.localName !== other.localName ||\r\n                    this.attributes.length !== other.attributes.length) {\r\n                    return false;\r\n                }\r\n            case Node.ATTRIBUTE_NODE:\r\n                if (this.namespaceURI !== other.namespaceURI ||\r\n                    this.localName !== other.localName ||\r\n                    this.value !== other.value) {\r\n                    return false;\r\n                }\r\n            case Node.PROCESSING_INSTRUCTION_NODE:\r\n                if (this.target !== other.target ||\r\n                    this.data !== other.data) {\r\n                    return false;\r\n                }\r\n            case Node.TEXT_NODE:\r\n            case Node.COMMENT_NODE:\r\n                if (this.data !== other.data) {\r\n                    return false;\r\n                }\r\n        }\r\n\r\n        if (this.nodeType == Node.ELEMENT_NODE) {\r\n            for (let i = 0; i < this.attributes.length; i++) {\r\n                let attr1 = this.attributes[i];\r\n                let attr2 = other.attributes[attr1.name];\r\n                if (attr1.value !== attr2.value) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        let childNodes1 = this.childNodes;\r\n        let childNodes2 = other.childNodes;\r\n        if (childNodes1.length !== other.childNodes.length) {\r\n            return false;\r\n        }\r\n\r\n        for (let i = 0; i < childNodes1.length; i++) {\r\n            if (!childNodes1[i].isEqualNode(childNodes2[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // TODO: tests\r\n    compareDocumentPosition(other) {\r\n        // https://dom.spec.whatwg.org/#dom-node-comparedocumentposition\r\n\r\n        if (this === other) {\r\n            return 0;\r\n        }\r\n\r\n        let node1 = other;\r\n        let node2 = this;\r\n        let attr1 = null;\r\n        let attr2 = null;\r\n\r\n        if (node1.nodeType == Document.prototype.ATTRIBUTE_NODE) {\r\n            attr1 = node1;\r\n            node1 = attr1.ownerElement;\r\n        }\r\n\r\n        if (node2.nodeType == Document.prototype.ATTRIBUTE_NODE) {\r\n            attr2 = node2;\r\n            node2 = attr2.ownerElement;\r\n\r\n            if (attr1 && node1 && node2 === node1) {\r\n                let attrs = node2.atttributes;\r\n                for (let i = 0; i < attrs.length; i++) {\r\n                    const attr = attrs[i];\r\n                    if (attr.isEqualNode(attr1)) {\r\n                        return Document.prototype.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\r\n                            + Document.prototype.DOCUMENT_POSITION_PRECEDING;\r\n                    }\r\n                    else if (attr.isEqualNode(attr2)) {\r\n                        return Document.prototype.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\r\n                            + Document.prototype.DOCUMENT_POSITION_FOLLOWING;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!node1 || !node2 || node1.getRootNode() !== node2.getRootNode()) {\r\n            return Document.prototype.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\r\n                + Document.prototype.DOCUMENT_POSITION_FOLLOWING\r\n                + Document.prototype.DOCUMENT_POSITION_DISCONNECTED;\r\n        }\r\n\r\n        if (ancestorOf(node2, node1) || ((node1 === node2) && attr2)) {\r\n            return Document.prototype.DOCUMENT_POSITION_CONTAINS\r\n                + Document.prototype.DOCUMENT_POSITION_PRECEDING;\r\n        }\r\n\r\n        if (ancestorOf(node1, node2) || ((node1 === node2) && attr1)) {\r\n            return Document.prototype.DOCUMENT_POSITION_CONTAINS\r\n                + Document.prototype.DOCUMENT_POSITION_FOLLOWING;\r\n        }\r\n\r\n        if (preceding(node1, node2)) {\r\n            return Document.prototype.DOCUMENT_POSITION_PRECEDING;\r\n        }\r\n\r\n        return Document.prototype.DOCUMENT_POSITION_FOLLOWING;\r\n    }\r\n\r\n    // TODO: tests\r\n    contains(node) {\r\n        // https://dom.spec.whatwg.org/#dom-node-contains\r\n\r\n        let parent = node.parentNode;\r\n\r\n        if (!parent) {\r\n            return false;\r\n        }\r\n\r\n        do {\r\n            if (parent === this) {\r\n                return true;\r\n            }\r\n        }\r\n        while (parent = parent.parentNode);\r\n\r\n        return false;\r\n    }\r\n\r\n    // TODO: tests\r\n    insertBefore(node, child) {\r\n        // https://dom.spec.whatwg.org/#dom-node-insertbefore\r\n        // The insertBefore(node, child) method, when invoked, must return the result \r\n        // of pre-inserting node into context object before child.\r\n        return $.preInsert(node, this, child);\r\n    }\r\n\r\n    // TODO: tests\r\n    appendChild(node) {\r\n        // https://dom.spec.whatwg.org/#dom-node-appendchild\r\n        // The appendChild(node) method, when invoked, must return the result of \r\n        // appending node to context object.\r\n        return $.append(node, this);\r\n    }\r\n\r\n    // TODO: tests\r\n    replaceChild(node, child) {\r\n        // https://dom.spec.whatwg.org/#dom-node-replacechild\r\n        // The replaceChild(node, child) method, when invoked, must return the \r\n        // result of replacing child with node within context object.\r\n        return $.replace(child, node, this);\r\n    }\r\n\r\n    // TODO: tests\r\n    removeChild(child) {\r\n        // https://dom.spec.whatwg.org/#dom-node-removechild\r\n        // The removeChild(child) method, when invoked, must return the result of \r\n        // pre-removing child from context object.\r\n        return $.preRemove(child, this);\r\n    }\r\n\r\n}\r\n\r\nfunction ancestorOf(node, ancestor) {\r\n    let parent = node.parentNode;\r\n\r\n    do {\r\n        if (parent === ancestor) {\r\n            return true;\r\n        }\r\n    }\r\n    while (parent = parent.parentNode);\r\n\r\n    return false;\r\n}\r\n\r\nfunction preceding(element1, element2) {\r\n    function precedingSiblings(parent, sibling1, sibling2) {\r\n        let siblings = parent.childNodes;\r\n        for (let i = 0; i < siblings.length; i++) {\r\n            let sibling = siblings[i];\r\n            if (sibling === sibling1) {\r\n                return true;\r\n            }\r\n            else if (sibling === sibling2) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Check if they're already siblings.\r\n    let ancestor1 = element1.parentNode;\r\n    let ancestor2 = element2.parentNode;\r\n\r\n    if (ancestor1 === ancestor2) {\r\n        return precedingSiblings(element1, element2);\r\n    }\r\n\r\n    // Find the closest common ancestor.\r\n    let ancestors1 = [ancestor1];\r\n    let ancestors2 = [ancestor2];\r\n\r\n    while (ancestor1 = ancestor1.parentNode) {\r\n        ancestors1.push(ancestor1);\r\n    }\r\n\r\n    while (ancestor2 = ancestor2.parentNode) {\r\n        ancestors2.push(ancestor2);\r\n    }\r\n\r\n    ancestors1.reverse();\r\n    ancestors2.reverse();\r\n\r\n    let diff = Math.abs(ancestors1.length - ancestors2.length);\r\n    let min = Math.min(ancestors1.length, ancestors2.length);\r\n\r\n    let i = 0;\r\n    while (ancestors1[i] === ancestors2[i]) {\r\n        i++;\r\n    }\r\n\r\n    return precedingSiblings(ancestors1[i - 1], ancestors1[i], ancestors2[i]);\r\n}",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#interface-shadowroot\r\nhttps://www.w3.org/TR/shadow-dom/#the-shadowroot-interface\r\n\r\n[Exposed=Window]\r\ninterface ShadowRoot : DocumentFragment\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nexport default class {\r\n\r\n    get nodeName() {\r\n        return '#shadow-root';\r\n    }\r\n\r\n    get mode() {\r\n        return $.shadow(this).mode;\r\n    }\r\n\r\n    get host() {\r\n        return $.shadow(this).host;\r\n    }\r\n\r\n    // TODO: tests\r\n    get innerHTML() {\r\n        return $.serializeHTMLFragment(this);\r\n    }\r\n\r\n    // TODO: tests\r\n    set innerHTML(value) {\r\n        const fragment = $.parseHTMLFragment(value, this);\r\n        $.replaceAll(fragment, this);\r\n    }\r\n\r\n}",
    "import patch from './patch.js';\r\n\r\nconst nativeShadowDom = 'attachShadow' in Element.prototype;\r\n\r\nif (!nativeShadowDom || window.forceShadowDomPolyfill) {\r\n    patch();\r\n}",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#interface-childnode\r\n\r\n[NoInterfaceObject, Exposed=Window]\r\ninterface ChildNode\r\n\r\nDocumentType implements ChildNode;\r\nElement implements ChildNode;\r\nCharacterData implements ChildNode;\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nexport default function (base) {\r\n\r\n    return class {\r\n\r\n        // TODO: tests\r\n        before(...nodes) {\r\n            // https://dom.spec.whatwg.org/#dom-childnode-before\r\n            // The before(nodes) method, when invoked, must run these steps:\r\n\r\n            // 1. Let parent be context object’s parent.\r\n            const parent = this.parentNode;\r\n\r\n            // 2. If parent is null, terminate these steps.\r\n            if (!parent) {\r\n                return;\r\n            }\r\n\r\n            // 3. Let viablePreviousSibling be context object’s first preceding \r\n            // sibling not in nodes, and null otherwise.\r\n            let viablePreviousSibling = this.previousSibling;\r\n            while (viablePreviousSibling && nodes.indexOf(viablePreviousSibling) !== -1) {\r\n                viablePreviousSibling = viablePreviousSibling.previousSibling;\r\n            }\r\n\r\n            // 4. Let node be the result of converting nodes into a node, given \r\n            // nodes and context object’s node document. Rethrow any exceptions.\r\n            const node = $.convertNodesIntoANode(nodes, this.ownerDocument);\r\n\r\n            // 5. If viablePreviousSibling is null, set it to parent’s first child, \r\n            // and to viablePreviousSibling’s next sibling otherwise.\r\n            if (viablePreviousSibling === null) {\r\n                viablePreviousSibling = parent.firstChild;\r\n            }\r\n            else {\r\n                viablePreviousSibling = viablePreviousSibling.nextSibling;\r\n            }\r\n\r\n            // 6. Pre-insert node into parent before viablePreviousSibling. \r\n            // Rethrow any exceptions.\r\n            $.preInsert(node, parent, viablePreviousSibling);\r\n        }\r\n\r\n        // TODO: tests\r\n        after(...nodes) {\r\n            // https://dom.spec.whatwg.org/#dom-childnode-after\r\n            // The after(nodes) method, when invoked, must run these steps:\r\n\r\n            // 1. Let parent be context object’s parent.\r\n            const parent = this.parentNode;\r\n\r\n            // 2. If parent is null, terminate these steps.\r\n            if (!parent) {\r\n                return;\r\n            }\r\n\r\n            // 3. Let viableNextSibling be context object’s first following \r\n            // sibling not in nodes, and null otherwise.\r\n            let viableNextSibling = this.nextSibling;\r\n            while (viableNextSibling && nodes.indexOf(viableNextSibling) !== -1) {\r\n                viableNextSibling = viableNextSibling.nextSibling;\r\n            }\r\n\r\n            // 4. Let node be the result of converting nodes into a node, given \r\n            // nodes and context object’s node document. Rethrow any exceptions.\r\n            const node = $.convertNodesIntoANode(nodes, this.ownerDocument);\r\n\r\n            // 5. Pre-insert node into parent before viableNextSibling. Rethrow \r\n            // any exceptions.\r\n            $.preInsert(node, parent, viableNextSibling);\r\n        }\r\n\r\n        // TODO: tests\r\n        replaceWith(...nodes) {\r\n            // https://dom.spec.whatwg.org/#dom-childnode-replacewith\r\n            // The replaceWith(nodes) method, when invoked, must run these steps:\r\n\r\n            // 1. Let parent be context object’s parent.\r\n            const parent = this.parentNode;\r\n\r\n            // 2. If parent is null, terminate these steps.\r\n            if (!parent) {\r\n                return;\r\n            }\r\n\r\n            // 3. Let viableNextSibling be context object’s first following \r\n            // sibling not in nodes, and null otherwise.\r\n            let viableNextSibling = this.nextSibling;\r\n            while (viableNextSibling && nodes.indexOf(viableNextSibling) !== -1) {\r\n                viableNextSibling = viableNextSibling.nextSibling;\r\n            }\r\n\r\n            // 4. Let node be the result of converting nodes into a node, given \r\n            // nodes and context object’s node document. Rethrow any exceptions.\r\n            const node = $.convertNodesIntoANode(nodes, this.ownerDocument);\r\n\r\n            // 5. If context object’s parent is parent, replace the context object \r\n            // with node within parent. Rethrow any exceptions.\r\n            if (this.parentNode == parent) {\r\n                parent.replaceChild(this, node);\r\n            }\r\n            // 6. Otherwise, pre-insert node into parent before viableNextSibling. \r\n            // Rethrow any exceptions.\r\n            else {\r\n                parent.insertBefore(node, viableNextSibling);\r\n            }\r\n        }\r\n\r\n        // TODO: tests\r\n        remove() {\r\n            // https://dom.spec.whatwg.org/#dom-childnode-remove\r\n            // The remove() method, when invoked, must run these steps:\r\n\r\n            // 1. If context object’s parent is null, terminate these steps.\r\n            const parent = this.parentNode;\r\n\r\n            if (!parent) {\r\n                return;\r\n            }\r\n\r\n            // 2. Remove the context object from context object’s parent.\r\n            $.remove(this, parent);\r\n        }\r\n\r\n    };\r\n\r\n}",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#mixin-documentorshadowroot\r\nhttps://www.w3.org/TR/shadow-dom/#extensions-to-the-documentorshadowroot-mixin\r\n\r\n[NoInterfaceObject, Exposed=Window]\r\ninterface DocumentOrShadowRoot\r\n\r\nDocument implements DocumentOrShadowRoot;\r\nShadowRoot implements DocumentOrShadowRoot;\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nexport default function (base) {\r\n\r\n    const native = {\r\n        activeElement: $.prop(base, 'activeElement')\r\n    };\r\n\r\n    return class {\r\n\r\n        /*\r\n    \r\n        https://www.w3.org/TR/shadow-dom/#extensions-to-the-documentorshadowroot-mixin\r\n    \r\n        */\r\n\r\n        // TODO: impl, tests\r\n        get activeElement() {\r\n            return native.activeElement.get.call(this);\r\n        }\r\n\r\n    };\r\n\r\n}",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#interface-nondocumenttypechildnode\r\n\r\n[NoInterfaceObject, Exposed=Window]\r\ninterface NonDocumentTypeChildNode\r\n\r\nElement implements NonDocumentTypeChildNode;\r\nCharacterData implements NonDocumentTypeChildNode;\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nexport default function (base) {\r\n\r\n    const native = {\r\n        previousElementSibling: $.prop(base, 'previousElementSibling'),\r\n        nextElementSibling: $.prop(base, 'nextElementSibling')\r\n    };\r\n\r\n    return class {\r\n\r\n        // TODO: tests\r\n        get previousElementSibling() {\r\n            let parentNode = $.shadow(this).parentNode;\r\n\r\n            if (!parentNode) {\r\n                if (native.previousElementSibling) {\r\n                    return native.previousElementSibling.get(this);\r\n                }\r\n                parentNode = this.parentNode;\r\n            }\r\n\r\n            const childNodes = $.shadow(parentNode).childNodes;\r\n            let index = childNodes.indexOf(this);\r\n\r\n            if (index === 0) {\r\n                return null;\r\n            }\r\n\r\n            do {\r\n                const previous = childNodes[--index];\r\n\r\n                if (previous.nodeType === Node.ELEMENT_NODE) {\r\n                    return previous;\r\n                }\r\n            }\r\n            while (index > 0);\r\n\r\n            return null;\r\n        }\r\n\r\n        // TODO: tests\r\n        get nextElementSibling() {\r\n            let parentNode = $.shadow(this).parentNode;\r\n\r\n            if (!parentNode) {\r\n                if (native.nextElementSibling) {\r\n                    return native.nextElementSibling.get(this);\r\n                }\r\n                parentNode = this.parentNode;\r\n            }\r\n            \r\n            const childNodes = $.shadow(parentNode).childNodes;\r\n            let index = childNodes.indexOf(this);\r\n\r\n            if (index === childNodes.length - 1) {\r\n                return null;\r\n            }\r\n\r\n            do {\r\n                const previous = childNodes[++index];\r\n\r\n                if (previous.nodeType === Node.ELEMENT_NODE) {\r\n                    return previous;\r\n                }\r\n            }\r\n            while (index < childNodes.length);\r\n\r\n            return null;\r\n        }\r\n\r\n    };\r\n\r\n}",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#interface-nonelementparentnode\r\n\r\n[NoInterfaceObject, Exposed=Window]\r\ninterface NonElementParentNode\r\n\r\nDocument implements NonElementParentNode;\r\nDocumentFragment implements NonElementParentNode;\r\n\r\n*/\r\n\r\nexport default function (base) {\r\n\r\n    return class {\r\n\r\n        getElementById(id) {\r\n            // https://dom.spec.whatwg.org/#dom-nonelementparentnode-getelementbyid\r\n\r\n            let firstChild = this.firstChild;\r\n\r\n            if (!firstChild) {\r\n                return null;\r\n            }\r\n\r\n            const stack = [{ node: firstChild, recursed: false }];\r\n\r\n            while (stack.length) {\r\n                const frame = stack.pop();\r\n\r\n                if (frame.recursed) {\r\n                    if (frame.node.nextSibling) {\r\n                        stack.push({ node: frame.node.nextSibling, recursed: false });\r\n                    }\r\n                }\r\n                else {\r\n                    if (frame.node.id === id) {\r\n                        return frame.node;\r\n                    }\r\n\r\n                    stack.push({ node: frame.node, recursed: true });\r\n\r\n                    if (firstChild = frame.node.firstChild) {\r\n                        stack.push({ node: firstChild, recursed: false });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n    };\r\n\r\n}",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#interface-parentnode\r\n\r\n[NoInterfaceObject, Exposed=Window]\r\ninterface ParentNode\r\n\r\nDocument implements ParentNode;\r\nDocumentFragment implements ParentNode;\r\nElement implements ParentNode;\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nexport default function (base) {\r\n\r\n    const native = {\r\n        children: $.prop(base, 'children'),\r\n        firstElementChild: $.prop(base, 'firstElementChild'),\r\n        lastElementChild: $.prop(base, 'lastElementChild'),\r\n        childElementCount: $.prop(base, 'childElementCount'),\r\n    };\r\n\r\n    return class {\r\n\r\n        get children() {\r\n            let childNodes = $.shadow(this).childNodes;\r\n\r\n            if (!childNodes) {\r\n                if (native.children) {\r\n                    return native.children.get.call(this);\r\n                }\r\n                childNodes = this.childNodes;\r\n            }\r\n\r\n            const elements = [];\r\n\r\n            for (let i = 0; i < childNodes.length; i++) {\r\n                const node = childNodes[i];\r\n                if (node.nodeType == Node.ELEMENT_NODE) {\r\n                    elements.push(node);\r\n                }\r\n            }\r\n\r\n            return elements;\r\n        }\r\n\r\n        get firstElementChild() {\r\n            let childNodes = $.shadow(this).childNodes;\r\n\r\n            if (!childNodes) {\r\n                if (native.firstElementChild) {\r\n                    return native.firstElementChild.get.call(this);\r\n                }\r\n                childNodes = this.childNodes;\r\n            }\r\n\r\n            for (let i = 0; i < childNodes.length; i++) {\r\n                const node = childNodes[i];\r\n                if (node.nodeType == Node.ELEMENT_NODE) {\r\n                    return node;\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        get lastElementChild() {\r\n            let childNodes = $.shadow(this).childNodes;\r\n\r\n            if (!childNodes) {\r\n                if (native.lastElementChild) {\r\n                    return native.lastElementChild.get.call(this);\r\n                }\r\n                childNodes = this.childNodes;\r\n            }\r\n\r\n            for (let i = childNodes.length - 1; i >= 0; i--) {\r\n                const node = childNodes[i];\r\n                if (node.nodeType == Node.ELEMENT_NODE) {\r\n                    return node;\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        get childElementCount() {\r\n            let childNodes = $.shadow(this).childNodes;\r\n\r\n            if (!childNodes) {\r\n                if (native.childElementCount) {\r\n                    return native.childElementCount.get.call(this);\r\n                }\r\n                childNodes = this.childNodes;\r\n            }\r\n\r\n            let count = 0;\r\n\r\n            for (let i = 0; i < childNodes.length; i++) {\r\n                const node = childNodes[i];\r\n                if (node.nodeType == Node.ELEMENT_NODE) {\r\n                    count++;\r\n                }\r\n            }\r\n\r\n            return count;\r\n        }\r\n\r\n        // TODO: tests\r\n        prepend(...nodes) {\r\n            // https://dom.spec.whatwg.org/#dom-parentnode-prepend\r\n            // The prepend(nodes) method, when invoked, must run these steps:\r\n\r\n            // 1. Let node be the result of converting nodes into a node given \r\n            // nodes and context object’s node document. Rethrow any exceptions.\r\n            const node = $.convertNodesIntoANode(nodes, this.ownerDocument || this);\r\n\r\n            // 2. Pre-insert node into context object before the context object’s \r\n            // first child. Rethrow any exceptions.\r\n            $.preInsert(node, this, this.firstChild);\r\n        }\r\n\r\n        // TODO: tests\r\n        append(...nodes) {\r\n            // https://dom.spec.whatwg.org/#dom-parentnode-append\r\n            // The append(nodes) method, when invoked, must run these steps:\r\n\r\n            // 1. Let node be the result of converting nodes into a node given \r\n            // nodes and context object’s node document. Rethrow any exceptions.\r\n            const node = $.convertNodesIntoANode(nodes, this.ownerDocument || this);\r\n\r\n            // 2. Append node to context object. Rethrow any exceptions.\r\n            $.append(node, this);\r\n        }\r\n\r\n        // TODO: tests\r\n        querySelector(selectors) {\r\n            const results = this.querySelectorAll(selectors);\r\n\r\n            if (results.length) {\r\n                return results[0];\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        // TODO: tests\r\n        querySelectorAll(selectors) {\r\n            // https://dom.spec.whatwg.org/#scope-match-a-selectors-string\r\n            // this is horrible, performance-wise.\r\n            // it's about 100x slower than native querySelectorAll.\r\n            // that might not amount to much in practice, though.\r\n            // after all, this is a polyfill.\r\n\r\n            let firstChild = this.firstChild;\r\n\r\n            if (!firstChild) {\r\n                return null;\r\n            }\r\n\r\n            const stack = [{ node: firstChild, recursed: false }];\r\n            const results = [];\r\n\r\n            while (stack.length) {\r\n                const frame = stack.pop();\r\n\r\n                if (frame.recursed) {\r\n                    if (frame.node.nextSibling) {\r\n                        stack.push({ node: frame.node.nextSibling, recursed: false });\r\n                    }\r\n                }\r\n                else {\r\n                    if (frame.node.nodeType == Node.ELEMENT_NODE && frame.node.matches(selectors)) {\r\n                        results.push(frame.node);\r\n                    }\r\n\r\n                    stack.push({ node: frame.node, recursed: true });\r\n\r\n                    if (firstChild = frame.node.firstChild) {\r\n                        stack.push({ node: firstChild, recursed: false });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return results;\r\n        }\r\n\r\n    };\r\n\r\n}",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#mixin-slotable\r\n\r\n[NoInterfaceObject, Exposed=Window]\r\ninterface Slotable\r\n\r\nElement implements Slotable;\r\nText implements Slotable;\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nexport default function(base) {\r\n    \r\n    return class {\r\n\r\n        get assignedSlot() {\r\n            // TODO: efficiency (https://github.com/whatwg/dom/issues/369)\r\n            return $.findASlot(this, true);\r\n        }\r\n\r\n    };\r\n\r\n}",
    "import * as $ from './utils.js';\r\n\r\nimport $Document from './interfaces/Document.js';\r\nimport $Element from './interfaces/Element.js';\r\nimport $Event from './interfaces/Event.js';\r\nimport $EventTarget from './interfaces/EventTarget.js';\r\nimport $HTMLSlotElement from './interfaces/HTMLSlotElement.js';\r\nimport $HTMLTableElement from './interfaces/HTMLTableElement.js';\r\nimport $HTMLTableRowElement from './interfaces/HTMLTableRowElement.js';\r\nimport $HTMLTableSectionElement from './interfaces/HTMLTableSectionElement.js';\r\nimport $Node from './interfaces/Node.js';\r\nimport $ShadowRoot from './interfaces/ShadowRoot.js';\r\n\r\nimport $ChildNode from './mixins/ChildNode.js';\r\nimport $DocumentOrShadowRoot from './mixins/DocumentOrShadowRoot.js';\r\nimport $NonDocumentTypeChildNode from './mixins/NonDocumentTypeChildNode.js';\r\nimport $NonElementParentNode from './mixins/NonElementParentNode.js';\r\nimport $ParentNode from './mixins/ParentNode.js';\r\nimport $Slotable from './mixins/Slotable.js';\r\n\r\n// In case we would force the polyfill\r\nconst HTMLSlotElement = window.HTMLSlotElement || window.HTMLUnknownElement;\r\n\r\nexport default function() {\r\n\r\n    // Element.matches(selectors) polyfill from MDN\r\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill\r\n\r\n    if (!Element.prototype.matches) {\r\n        Element.prototype.matches = \r\n            Element.prototype.matchesSelector || \r\n            Element.prototype.mozMatchesSelector ||\r\n            Element.prototype.msMatchesSelector || \r\n            Element.prototype.oMatchesSelector || \r\n            Element.prototype.webkitMatchesSelector ||\r\n            function(s) {\r\n                const matches = (this.document || this.ownerDocument).querySelectorAll(s);\r\n                let i = matches.length;\r\n                while (--i >= 0 && matches.item(i) !== this) {}\r\n                return i > -1;            \r\n            };\r\n    }\r\n\r\n    // Globally applied interfaces\r\n\r\n    $.extend(Document, $Document);\r\n    $.extend(Element, $Element);\r\n    $.extend(Event, $Event);\r\n\r\n    if ('EventTarget' in Window) {\r\n        $.extend(EventTarget, $EventTarget(EventTarget));\r\n    }\r\n    else {\r\n        // In IE, EventTarget is not exposed and Window's\r\n        // EventTarget methods are not the same as Node's.\r\n        $.extend(Window, $EventTarget(Window));\r\n        $.extend(Node, $EventTarget(Node));\r\n    }\r\n\r\n    $.extend(HTMLSlotElement, $HTMLSlotElement);\r\n    $.extend(HTMLTableElement, $HTMLTableElement);\r\n    $.extend(HTMLTableRowElement, $HTMLTableRowElement);\r\n    $.extend(HTMLTableSectionElement, $HTMLTableSectionElement);\r\n    $.extend(Node, $Node);\r\n\r\n    // Globally applied mixins\r\n\r\n    $.extend(DocumentType, $ChildNode(DocumentType));\r\n    $.extend(Element, $ChildNode(Element));\r\n    $.extend(CharacterData, $ChildNode(CharacterData));\r\n\r\n    $.extend(Document, $DocumentOrShadowRoot(Document));\r\n    $.extend($ShadowRoot, $DocumentOrShadowRoot($ShadowRoot));\r\n\r\n    $.extend(Element, $NonDocumentTypeChildNode(Element));\r\n    $.extend(CharacterData, $NonDocumentTypeChildNode(CharacterData));\r\n\r\n    $.extend(Document, $NonElementParentNode(Document));\r\n    $.extend(DocumentFragment, $NonElementParentNode(DocumentFragment));\r\n\r\n    $.extend(Document, $ParentNode(Document));\r\n    $.extend(DocumentFragment, $ParentNode(DocumentFragment));\r\n    $.extend(Element, $ParentNode(Element));\r\n\r\n    $.extend(Element, $Slotable(Element));\r\n    $.extend(Text, $Slotable(Text));\r\n\r\n    // For IE, Edge\r\n\r\n    delete HTMLElement.prototype.children;\r\n    delete HTMLElement.prototype.parentElement;\r\n    delete HTMLElement.prototype.innerHTML;\r\n    delete HTMLElement.prototype.outerHTML;\r\n    delete HTMLElement.prototype.insertAdjacentText;\r\n    delete HTMLElement.prototype.insertAdjacentElement;\r\n    delete HTMLElement.prototype.insertAdjacentHTML;\r\n\r\n}",
    "export const prop = (type, name) =>\r\n    Object.getOwnPropertyDescriptor(type.prototype, name);\r\n\r\nexport const native = {\r\n    Document: {\r\n        getElementsByTagName: Document.prototype.getElementsByTagName,\r\n        getElementsByTagNameNS: Document.prototype.getElementsByTagNameNS,\r\n        getElementsByClassName: Document.prototype.getElementsByClassName\r\n    },\r\n    Element: {\r\n        getElementsByTagName: Element.prototype.getElementsByTagName,\r\n        getElementsByTagNameNS: Element.prototype.getElementsByTagNameNS,\r\n        getElementsByClassName: Element.prototype.getElementsByClassName,\r\n        innerHTML: prop(Element, 'innerHTML') || prop(HTMLElement, 'innerHTML'),\r\n        setAttribute: Element.prototype.setAttribute\r\n    },\r\n    Node: {\r\n        parentNode: prop(Node, 'parentNode'),\r\n        hasChildNodes: Node.prototype.hasChildNodes,\r\n        childNodes: prop(Node, 'childNodes'),\r\n        firstChild: prop(Node, 'firstChild'),\r\n        lastChild: prop(Node, 'lastChild'),\r\n        previousSibling: prop(Node, 'previousSibling'),\r\n        nextSibling: prop(Node, 'nextSibling'),\r\n        textContent: prop(Node, 'textContent'),\r\n        normalize: Node.prototype.normalize,\r\n        cloneNode: Node.prototype.cloneNode,\r\n        insertBefore: Node.prototype.insertBefore,\r\n        removeChild: Node.prototype.removeChild,\r\n        appendChild: Node.prototype.appendChild\r\n    }\r\n};\r\n\r\nexport const slice = array => Array.prototype.slice.call(array);\r\n\r\nexport function makeError(name, message) {\r\n    const error = new Error(message || name);\r\n    error.name = name;\r\n    return error;\r\n}\r\n\r\nexport function extend(object, ...mixins) {\r\n    for (let i = 0; i < mixins.length; i++) {\r\n        const mixin = mixins[i].prototype;\r\n        const names = Object.getOwnPropertyNames(mixin);\r\n        for (let j = 0; j < names.length; j++) {\r\n            const name = names[j];\r\n            if (name === 'constructor') {\r\n                continue;\r\n            }\r\n            const descriptor = Object.getOwnPropertyDescriptor(mixin, name);\r\n            Object.defineProperty(object.prototype || object, name, descriptor);\r\n        }\r\n    }\r\n}\r\n\r\nexport function shadow(object, info) {\r\n    const shadow = object._shadow || {};\r\n    if (info) {\r\n        const names = Object.getOwnPropertyNames(info);\r\n        for (let i = 0; i < names.length; i++) {\r\n            const name = names[i];\r\n            shadow[name] = info[name];\r\n        }\r\n    }\r\n    return object._shadow = shadow;\r\n}\r\n\r\nexport function convertNodesIntoANode(nodes, document) {\r\n    // https://dom.spec.whatwg.org/#converting-nodes-into-a-node\r\n    let node = null;\r\n\r\n    for (let i = 0; i < nodes.length; i++) {\r\n        const item = nodes[i];\r\n\r\n        if (typeof item === \"string\") {\r\n            nodes[i] = document.createTextNode(item);\r\n        }\r\n    }\r\n\r\n    if (nodes.length === 1) {\r\n        node = nodes[0];\r\n    }\r\n    else {\r\n        node = document.createDocumentFragment();\r\n\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            node.appendChild(nodes[i]);\r\n        }\r\n    }\r\n\r\n    return node;\r\n}\r\n\r\nexport function isValidCustomElementName(localName) {\r\n    // https://html.spec.whatwg.org/multipage/scripting.html#valid-custom-element-name\r\n    switch (localName) {\r\n        case \"annotation-xml\":\r\n        case \"color-profile\":\r\n        case \"font-face\":\r\n        case \"font-face-src\":\r\n        case \"font-face-uri\":\r\n        case \"font-face-format\":\r\n        case \"font-face-name\":\r\n        case \"missing-glyph\":\r\n            return false;\r\n    }\r\n\r\n    // For now, to reduce complexity, we are leaving the unicode sets out...\r\n    const regex = /[a-z](-|\\.|[0-9]|_|[a-z])+-(-|\\.|[0-9]|_|[a-z])+/g;\r\n\r\n    return regex.test(localName);\r\n}\r\n\r\nexport function shadowIncludingDescendant(nodeA, nodeB) {\r\n    do {\r\n        if (nodeA.nodeName === '#shadow-root') {\r\n            nodeA = nodeA.host;\r\n        }\r\n        else {\r\n            nodeA = nodeA.parentNode;\r\n        }\r\n        if (nodeA === nodeB) {\r\n            return true;\r\n        }\r\n    }\r\n    while (nodeA !== null);\r\n    return false;\r\n}\r\n\r\nexport function shadowIncludingInclusiveDescendant(nodeA, nodeB) {\r\n    return nodeA === nodeB || shadowIncludingDescendant(nodeA, nodeB);\r\n}\r\n\r\nexport function shadowIncludingAncestor(nodeA, nodeB) {\r\n    return shadowIncludingDescendant(nodeB, nodeA);\r\n}\r\n\r\nexport function shadowIncludingInclusiveAncestor(nodeA, nodeB) {\r\n    return nodeA === nodeB || shadowIncludingAncestor(nodeA, nodeB);\r\n}\r\n\r\nexport function closedShadowHidden(nodeA, nodeB) {\r\n    // https://dom.spec.whatwg.org/#concept-closed-shadow-hidden\r\n    const root = nodeA.getRootNode({ composed: false });\r\n\r\n    if (root.localName !== '#shadow-root') {\r\n        return false;\r\n    }\r\n\r\n    if (shadowIncludingInclusiveAncestor(root, nodeB)) {\r\n        return false;\r\n    }\r\n\r\n    if (root.mode === 'closed' || closedShadowHidden(root.host, nodeB)) {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nexport function retarget(nodeA, nodeB) {\r\n    // https://dom.spec.whatwg.org/#retarget\r\n    // To retarget an object A against an object B, repeat these steps \r\n    // until they return an object:\r\n\r\n    let root;\r\n    while (root = nodeA.getRootNode()) {\r\n        // 1. If A’s root is not a shadow root, or A’s root is a shadow-including \r\n        // inclusive ancestor of B, then return A.\r\n        if (root.localName !== '#shadow-root' || shadowIncludingInclusiveAncestor(root, nodeB)) {\r\n            return nodeA;\r\n        }\r\n        // 2. Set A to A’s root’s host.\r\n        nodeA = root.host;\r\n    }\r\n}\r\n\r\nexport function insertAdjacent(element, where, node) {\r\n    if (!(node instanceof Node)) {\r\n        throw makeError('TypeError');\r\n    }\r\n    let parent;\r\n    // https://dom.spec.whatwg.org/#insert-adjacent\r\n    switch ((where || '').toLowerCase()) {\r\n        case \"beforebegin\":\r\n            if (parent = element.parentNode) {\r\n                return preInsert(node, parent, element);\r\n            }\r\n            return null;\r\n        case \"afterbegin\":\r\n            return preInsert(node, element, element.firstChild);\r\n        case \"beforeend\":\r\n            return preInsert(node, element, null);\r\n        case \"afterend\":\r\n            if (parent = element.parentNode) {\r\n                return preInsert(node, parent, element.nextSibling);\r\n            }\r\n            return null;\r\n        default:\r\n            throw makeError('SyntaxError');\r\n    }\r\n}\r\n\r\nexport function parseHTMLFragment(markup, context) {\r\n    let temp = context.ownerDocument.createElement('body');\r\n    native.Element.innerHTML.set.call(temp, markup);\r\n    const childNodes = native.Node.childNodes.get.call(temp);\r\n    const fragment = context.ownerDocument.createDocumentFragment();\r\n    for (let i = 0; i < childNodes.length; i++) {\r\n        native.Node.appendChild.call(fragment, childNodes[i]);\r\n    }\r\n    return fragment;\r\n}\r\n\r\nexport function serializeHTMLFragment(node) {\r\n    // https://www.w3.org/TR/html5/single-page.html#html-fragment-serialization-algorithm\r\n\r\n    // 1. Let s be a string, and initialize it to the empty string.\r\n    let s = '';\r\n\r\n    // 2. If the node is a template element, then let the node instead be the \r\n    // template element's template contents (a DocumentFragment node).\r\n    if (node.localName === 'template') {\r\n        const content = node.content;\r\n        if (content) {\r\n            node = content;\r\n        }\r\n    }\r\n\r\n    // 3. For each child node of the node, in tree order, run the following steps:\r\n    const childNodes = node.childNodes;\r\n    for (let i = 0; i < childNodes.length; i++) {\r\n        // 1. Let current node be the child node being processed.\r\n        const currentNode = childNodes[i];\r\n        // 2. Append the appropriate string from the following list to s:\r\n        switch (currentNode.nodeType) {\r\n            case Node.ELEMENT_NODE:\r\n                let tagName;\r\n                switch (currentNode.namespaceURI) {\r\n                    case 'http://www.w3.org/1999/xhtml':\r\n                    case 'http://www.w3.org/1998/Math/MathML':\r\n                    case 'http://www.w3.org/2000/svg':\r\n                        tagName = currentNode.localName;\r\n                        break;\r\n                    default:\r\n                        tagName = currentNode.qualifiedName;\r\n                        break;\r\n                }\r\n                s += '<' + tagName;\r\n                const attributes = currentNode.attributes;\r\n                for (let j = 0; j < attributes.length; j++) {\r\n                    const attribute = attributes[j];\r\n                    s += ' ' + serializeAttributeName(attribute);\r\n                    s += '=\"' + escapeString(attribute.value) + '\"';\r\n                }\r\n                s += '>';\r\n                switch (currentNode.localName) {\r\n                    case 'area': case 'base': case 'basefont': case 'bgsound':\r\n                    case 'br': case 'col': case 'embed': case 'frame': case 'hr':\r\n                    case 'img': case 'input': case 'keygen': case 'link': case 'meta':\r\n                    case 'param': case 'source': case 'track': case 'wbr':\r\n                        continue;\r\n                    case 'pre': case 'textarea': case 'listing':\r\n                        const firstChild = currentNode.firstChild;\r\n                        if (firstChild &&\r\n                            firstChild.nodeType === Node.TEXT_NODE &&\r\n                            firstChild.data[0] === '\\n') {\r\n                            s += '\\n';\r\n                        }\r\n                        break;\r\n                }\r\n                s += serializeHTMLFragment(currentNode);\r\n                s += '</' + tagName + '>';\r\n                break;\r\n            case Node.TEXT_NODE:\r\n                switch (currentNode.parentNode.localName) {\r\n                    case 'style': case 'script': case 'xmp': case 'iframe':\r\n                    case 'noembed': case 'noframes': case 'plaintext': case 'noscript':\r\n                        s += currentNode.data;\r\n                        break;\r\n                    default:\r\n                        s += escapeString(currentNode.data);\r\n                        break;\r\n                }\r\n                break;\r\n            case Node.COMMENT_NODE:\r\n                s += '<!--' + currentNode.data + '-->';\r\n                break;\r\n            case Node.PROCESSING_INSTRUCTION_NODE:\r\n                s += '<?' + currentNode.target + ' ' + currentNode.data + '>';\r\n                break;\r\n            case Node.DOCUMENT_TYPE_NODE:\r\n                s += '<!DOCTYPE ' + currentNode.name + '>';\r\n                break;\r\n        }\r\n    }\r\n\r\n    // 4. The result of the algorithm is the string s.\r\n    return s;\r\n\r\n    function escapeString(string, attributeMode) {\r\n        if (!string || !string.length) {\r\n            return '';\r\n        }\r\n\r\n        string = string.replace('&', '&amp;');\r\n        string = string.replace('\\xA0', '&nbsp;');\r\n\r\n        if (attributeMode) {\r\n            string = string.replace('\"', '&quot;');\r\n        }\r\n        else {\r\n            string = string.replace('<', '&lt;');\r\n            string = string.replace('>', '&gt;');\r\n        }\r\n\r\n        return string;\r\n    }\r\n\r\n    function serializeAttributeName(attribute) {\r\n        const namespaceURI = attribute.namespaceURI;\r\n        const localName = attribute.localName;\r\n        if (!namespaceURI) {\r\n            return localName;\r\n        }\r\n        switch (namespaceURI) {\r\n            case 'http://www.w3.org/XML/1998/namespace':\r\n                return 'xml:' + localName;\r\n            case 'http://www.w3.org/2000/xmlns/':\r\n                if (localName === 'xmlns') {\r\n                    return localName;\r\n                }\r\n                return 'xmlns:' + localName;\r\n            case 'http://www.w3.org/1999/xlink':\r\n                return 'xlink:' + localName;\r\n            default:\r\n                return attribute.name;\r\n        }\r\n    }\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#finding-slots-and-slotables\r\n\r\nexport function findASlot(slotable, open) {\r\n    // https://dom.spec.whatwg.org/#find-a-slot\r\n    // To find a slot for a given slotable slotable and an optional \r\n    // open flag (unset unless stated otherwise), run these steps:\r\n\r\n    // 1. If slotable’s parent is null, then return null.\r\n    const parent = slotable.parentNode;\r\n    if (!parent) {\r\n        return null;\r\n    }\r\n\r\n    // 2. Let shadow be slotable’s parent’s shadow root.\r\n    const shadowRoot = shadow(parent).shadowRoot;\r\n\r\n    // 3. If shadow is null, then return null.\r\n    if (!shadowRoot) {\r\n        return null;\r\n    }\r\n\r\n    // 4. If the open flag is set and shadow’s mode is not \"open\", then return null.\r\n    if (open === true && shadowRoot.mode !== 'open') {\r\n        return null;\r\n    }\r\n\r\n    // 5. Return the first slot in shadow’s tree whose name is slotable’s name, if any, and null otherwise.\r\n    if (!shadowRoot.firstChild) {\r\n        return null;\r\n    }\r\n\r\n    const name = slotable instanceof Element ? slotable.slot : null;\r\n    const stack = [{ node: shadowRoot.firstChild, recursed: false }];\r\n\r\n    while (stack.length) {\r\n        const frame = stack.pop();\r\n        const node = frame.node;\r\n\r\n        if (frame.recursed) {\r\n            if (node.nextSibling) {\r\n                stack.push({ node: node.nextSibling, recursed: false });\r\n            }\r\n        }\r\n        else {\r\n            if (node.localName === 'slot' && node.getAttribute('name') === name) {\r\n                return node;\r\n            }\r\n\r\n            stack.push({ node: frame.node, recursed: true });\r\n\r\n            if (node.firstChild) {\r\n                stack.push({ node: node.firstChild, recursed: false });\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nexport function findSlotables(slot) {\r\n    // https://dom.spec.whatwg.org/#find-slotables\r\n    // To find slotables for a given slot slot, run these steps:\r\n\r\n    // 1. Let result be an empty list.\r\n    const result = [];\r\n\r\n    // 2. If slot’s root is not a shadow root, then return result.\r\n    const root = slot.getRootNode({ composed: false });\r\n    if (root.nodeName != '#shadow-root') {\r\n        return result;\r\n    }\r\n\r\n    // 3. Let host be slot’s root’s host.\r\n    const host = root.host;\r\n\r\n    // 4. For each slotable child of host, slotable, in tree order, run these substeps:\r\n    const slotableChildren = slice(host.childNodes);\r\n    for (let i = 0; i < slotableChildren.length; i++) {\r\n        const slotable = slotableChildren[i];\r\n        if (slotable.nodeType === Node.ELEMENT_NODE\r\n            || slotable.nodeType === Node.TEXT_NODE) {\r\n            // 1. Let foundSlot be the result of finding a slot given slotable.\r\n            const foundSlot = findASlot(slotable);\r\n            // 2. If foundSlot is slot, then append slotable to result.\r\n            if (foundSlot === slot) {\r\n                result.push(slotable);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 5. Return result.\r\n    return result;\r\n}\r\n\r\nexport function findFlattenedSlotables(slot) {\r\n    // https://dom.spec.whatwg.org/#find-flattened-slotables\r\n    // To find flattened slotables for a given slot slot, run these steps:\r\n\r\n    // 1. Let result be an empty list.\r\n    const result = [];\r\n\r\n    // 2. Let slotables be the result of finding slotables given slot.\r\n    const slotables = findSlotables(slot);\r\n\r\n    // 3. If slotables is the empty list, then append each slotable child of slot, in tree order, to slotables.\r\n    if (slotables.length === 0) {\r\n        const slotableChildren = slice(slot.childNodes);\r\n        for (let i = 0; i < slotableChildren.length; i++) {\r\n            const slotableChild = slotableChildren[i];\r\n            if (slotableChild.nodeType === Node.ELEMENT_NODE\r\n                || slotableChild.nodeType === Node.TEXT_NODE) {\r\n                slotables.push(slotableChild);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 4. For each node in slotables, run these substeps:\r\n    for (let i = 0; i < slotables.length; i++) {\r\n        const node = slotables[i];\r\n        // 1. If node is a slot, run these subsubsteps:\r\n        if (node.localName === 'slot') {\r\n            const temporaryResult = findFlattenedSlotables(node);\r\n            result.splice(result.length, 0, ...temporaryResult);\r\n        }\r\n        else {\r\n            result.push(node);\r\n        }\r\n    }\r\n\r\n    // 5. Return result.\r\n    return result;\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#assigning-slotables-and-slots\r\n\r\nexport function assignSlotables(slot, suppressSignaling) {\r\n    // https://dom.spec.whatwg.org/#assign-slotables\r\n    // To assign slotables, for a slot slot with an optional suppress \r\n    // signaling flag (unset unless stated otherwise), run these steps:\r\n\r\n    // 1. Let slotables be the result of finding slotables for slot.\r\n    const slotables = findSlotables(slot);\r\n\r\n    // 2. If suppress signaling flag is unset, and slotables and slot’s assigned \r\n    // nodes are not identical, then run signal a slot change for slot.\r\n    if (!suppressSignaling) {\r\n        const assignedNodes = slot.assignedNodes();\r\n        if (slotables.length !== assignedNodes.length) {\r\n            signalASlotChange(slot);\r\n        }\r\n        else {\r\n            for (let i = 0; i < slotables.length; i++) {\r\n                if (slotables[i] !== assignedNodes[i]) {\r\n                    signalASlotChange(slot);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // 3. Set slot’s assigned nodes to slotables.\r\n    shadow(slot, { assignedNodes: slotables });\r\n\r\n    // 4. For each slotable in slotables, set slotable’s assigned slot to slot.\r\n\r\n    // 4a. If we haven't tracked them yet, track the slot's logical children\r\n    if (!shadow(slot).childNodes) {\r\n        shadow(slot, {\r\n            childNodes: slice(native.Node.childNodes.get.call(slot))\r\n        });\r\n    }\r\n\r\n    // 4b. We need to clean out the slot\r\n    let firstChild;\r\n    while (firstChild = native.Node.firstChild.get.call(slot)) {\r\n        native.Node.removeChild.call(slot, firstChild);\r\n    }\r\n\r\n    // 4c. do what the spec said\r\n    for (let i = 0; i < slotables.length; i++) {\r\n        const slotable = slotables[i];\r\n        shadow(slotable, { assignedSlot: slot });\r\n        native.Node.appendChild.call(slot, slotable);\r\n    }\r\n\r\n    // 4d. if there were no slotables we need to insert its fallback content\r\n    if (!slotables.length) {\r\n        const childNodes = shadow(slot).childNodes;\r\n        for (let i = 0; i < childNodes.length; i++) {\r\n            native.Node.appendChild.call(slot, childNodes[i]);\r\n        }\r\n    }\r\n}\r\n\r\nexport function assignSlotablesForATree(tree, noSignalSlots) {\r\n    // https://dom.spec.whatwg.org/#assign-slotables-for-a-tree\r\n    // To assign slotables for a tree, given a tree tree and an optional set of slots noSignalSlots\r\n    // (empty unless stated otherwise), run these steps for each slot slot in tree, in tree order:\r\n    const slots = [];\r\n\r\n    if (tree.localName === 'slot') {\r\n        slots.push(tree);\r\n    }\r\n\r\n    if (tree.hasChildNodes()) {\r\n        slots.push(...tree.querySelectorAll('slot'));\r\n    }\r\n\r\n    for (let i = 0; i < slots.length; i++) {\r\n        const slot = slots[i];\r\n\r\n        // 1. Let suppress signaling flag be set, if slot is in noSignalSlots, and unset otherwise.\r\n        const suppressSignaling = noSignalSlots && noSignalSlots.indexOf(slot) !== -1;\r\n\r\n        // 2. Run assign slotables for slot with suppress signaling flag.\r\n        assignSlotables(slot, suppressSignaling);\r\n    }\r\n}\r\n\r\nexport function assignASlot(slotable) {\r\n    const slot = findASlot(slotable);\r\n\r\n    if (slot !== null) {\r\n        assignSlotables(slot);\r\n    }\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#signaling-slot-change\r\n\r\nexport function signalASlotChange(slot) {\r\n    // https://dom.spec.whatwg.org/#signal-a-slot-change\r\n    // To signal a slot change, for a slot slot, run these steps:\r\n\r\n    // Skip (MutationObserver)\r\n    // 1. If slot is not in unit of related similar-origin browsing contexts' \r\n    // signal slot list, append slot to unit of related similar-origin browsing \r\n    // contexts' signal slot list.\r\n    // 2. Queue a mutation observer compound microtask.\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#mutation-algorithms\r\n\r\nexport function ensurePreInsertionValidity(node, parent, child) {\r\n    // https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\r\n    // To ensure pre-insertion validity of a node into a parent before a child, run these steps:\r\n\r\n    // Skip (native)\r\n    // 1. If parent is not a Document, DocumentFragment, or Element node, throw a HierarchyRequestError.\r\n\r\n    // 2. If node is a host-including inclusive ancestor of parent, throw a HierarchyRequestError.\r\n    let ancestor = parent;\r\n    do {\r\n        if (ancestor === node) {\r\n            throw makeError('HierarchyRequestError');\r\n        }\r\n    }\r\n    while (ancestor = (ancestor.parentNode || ancestor.host));\r\n\r\n    // 3. If child is not null and its parent is not parent, then throw a NotFoundError.\r\n    if (child !== null && child.parentNode !== parent) {\r\n        throw makeError('NotFoundError');\r\n    }\r\n\r\n    // Skip (native)\r\n    // 4. If node is not a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction, \r\n    // or Comment node, throw a HierarchyRequestError.\r\n    // 5. If either node is a Text node and parent is a document, or node is a doctype \r\n    // and parent is not a document, throw a HierarchyRequestError.\r\n    // 6. If parent is a document, and any of the statements below, switched on node, \r\n    // are true, throw a HierarchyRequestError.\r\n}\r\n\r\nexport function preInsert(node, parent, child) {\r\n    // https://dom.spec.whatwg.org/#concept-node-pre-insert\r\n    // To pre-insert a node into a parent before a child, run these steps:\r\n\r\n    // 1. Ensure pre-insertion validity of node into parent before child.\r\n    ensurePreInsertionValidity(node, parent, child);\r\n\r\n    // 2. Let reference child be child.\r\n    let referenceChild = child;\r\n\r\n    // 3. If reference child is node, set it to node’s next sibling.\r\n    referenceChild === node && (referenceChild = node.nextSibling);\r\n\r\n    // 4. Adopt node into parent’s node document.\r\n    // https://dom.spec.whatwg.org/#concept-node-adopt\r\n    adopt(node, parent.ownerDocument);\r\n\r\n    // 5. Insert node into parent before reference child.\r\n    // https://dom.spec.whatwg.org/#concept-node-insert\r\n    insert(node, parent, referenceChild);\r\n\r\n    // 6. Return node.\r\n    return node;\r\n}\r\n\r\nexport function insert(node, parent, child, suppressObservers) {\r\n    // https://dom.spec.whatwg.org/#concept-node-insert\r\n    // To insert a node into a parent before a child, with an optional suppress observers flag, run these steps:\r\n\r\n    // Skip (Range)\r\n    // 1. Let count be the number of children of node if it is a DocumentFragment node, and one otherwise.\r\n    // 2. If child is non-null, run these substeps:\r\n\r\n    // 3. Let nodes be node’s children if node is a DocumentFragment node, \r\n    // and a list containing solely node otherwise.\r\n    let nodes = (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE)\r\n        ? slice(node.childNodes) : [node];\r\n\r\n    // 4. If node is a DocumentFragment node, remove its children with the suppress observers flag set.\r\n    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            remove(nodes[i], node, true);\r\n        }\r\n    }\r\n\r\n    // Skip (MutationObserver)\r\n    // 5. If node is a DocumentFragment node, queue a mutation record of \"childList\" for node with removedNodes nodes.\r\n\r\n    // 6. For each node in nodes, in tree order, run these substeps:\r\n    for (let i = 0; i < nodes.length; i++) {\r\n        const node = nodes[i];\r\n        // 1. Insert node into parent before child or at the end of parent if child is null.\r\n        const childNodes = shadow(parent).childNodes;\r\n        if (childNodes) {\r\n            if (child) {\r\n                const childIndex = childNodes.indexOf(child);\r\n                childNodes.splice(childIndex, 0, node);\r\n            }\r\n            else {\r\n                childNodes.push(node);\r\n            }\r\n            shadow(node, { parentNode: parent });\r\n            // If it's a shadow root, perform physical insert on the host.\r\n            const shadowHost = shadow(parent).host;\r\n            if (shadowHost) {\r\n                native.Node.insertBefore.call(shadowHost, node, child);\r\n            }\r\n        }\r\n        else {\r\n            native.Node.insertBefore.call(parent, node, child);\r\n        }\r\n\r\n        // 2. If parent is a shadow host and node is a slotable, then assign a slot for node.\r\n        if (shadow(parent).shadowRoot && 'assignedSlot' in node) {\r\n            assignASlot(node);\r\n        }\r\n\r\n        // 3. If parent is a slot whose assigned nodes is the empty list, then run signal a slot change for parent.\r\n        if (parent.localName === 'slot' && parent.assignedNodes().length === 0) {\r\n            // 3a. Physically append the child into the slot.\r\n            native.Node.appendChild.call(parent, node);\r\n            // 3b. Do what the spec said\r\n            signalASlotChange(parent);\r\n        }\r\n\r\n        // 4. Run assign slotables for a tree with node’s tree and a set containing each inclusive descendant of node that is a slot.\r\n        const inclusiveSlotDescendants = [];\r\n        if (node.localName === 'slot') {\r\n            inclusiveSlotDescendants.push(node);\r\n        }\r\n        if (node.hasChildNodes()) {\r\n            inclusiveSlotDescendants.push(...node.querySelectorAll('slot'));\r\n        }\r\n        assignSlotablesForATree(node, inclusiveSlotDescendants);\r\n\r\n        // Skip (CustomElements)\r\n        // 5. For each shadow-including inclusive descendant inclusiveDescendant of node, \r\n        // in shadow-including tree order, run these subsubsteps:\r\n    }\r\n\r\n    // Skip (MutationObserver)\r\n    // 7. If suppress observers flag is unset, queue a mutation record of \"childList\" for parent \r\n    // with addedNodes nodes, nextSibling child, and previousSibling child’s previous sibling or \r\n    // parent’s last child if child is null.\r\n}\r\n\r\nexport function append(node, parent) {\r\n    // https://dom.spec.whatwg.org/#concept-node-append\r\n    // To append a node to a parent, pre-insert node into parent before null.\r\n    preInsert(node, parent, null);\r\n}\r\n\r\nexport function replace(child, node, parent) {\r\n    // https://dom.spec.whatwg.org/#concept-node-replace\r\n    // To replace a child with node within a parent, run these steps:\r\n\r\n    // Skip (native)\r\n    // 1. If parent is not a Document, DocumentFragment, or Element node, throw a HierarchyRequestError.\r\n\r\n    // 2. If node is a host-including inclusive ancestor of parent, throw a HierarchyRequestError.\r\n    let ancestor = parent;\r\n    do {\r\n        if (ancestor === node) {\r\n            throw makeError('HierarchyRequestError');\r\n        }\r\n    }\r\n    while (ancestor = (ancestor.parentNode || ancestor.host));\r\n\r\n    // 3. If child’s parent is not parent, then throw a NotFoundError.\r\n    if (child !== null && child.parentNode !== parent) {\r\n        throw makeError('NotFoundError');\r\n    }\r\n\r\n    // Skip (native)\r\n    // 4. If node is not a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction, or Comment node, throw a HierarchyRequestError.\r\n    // 5. If either node is a Text node and parent is a document, or node is a doctype and parent is not a document, throw a HierarchyRequestError.\r\n    // 6. If parent is a document, and any of the statements below, switched on node, are true, throw a HierarchyRequestError.\r\n\r\n    // 7. Let reference child be child’s next sibling.\r\n    let referenceChild = child.nextSibling;\r\n\r\n    // 8. If reference child is node, set it to node’s next sibling.\r\n    if (referenceChild === node) {\r\n        referenceChild = node.nextSibling;\r\n    }\r\n\r\n    // Skip (MutationObserver)\r\n    // 9. Let previousSibling be child’s previous sibling.\r\n    // const previousSibling = child.previousSibling;\r\n\r\n    // 10. Adopt node into parent’s node document.\r\n    adopt(node, parent.ownerDocument);\r\n\r\n    // Skip (MutationObserver)\r\n    // 11. Let removedNodes be the empty list.\r\n    // const removedNodes = [];\r\n\r\n    // 12. If child’s parent is not null, run these substeps:\r\n    const childParent = child.parentNode;\r\n    if (childParent !== null) {\r\n        // Skip (MutationObserver)\r\n        // 1. Set removedNodes to a list solely containing child.\r\n        // removedNodes.push(child);\r\n        // 2. Remove child from its parent with the suppress observers flag set.\r\n        remove(child, parent, true);\r\n    }\r\n\r\n    // Skip (MutationObserver)\r\n    // 13. Let nodes be node’s children if node is a DocumentFragment node, and a list containing solely node otherwise.\r\n\r\n    // 14. Insert node into parent before reference child with the suppress observers flag set.\r\n    insert(node, parent, referenceChild, true);\r\n\r\n    // Skip (MutationObserver)\r\n    // 15. Queue a mutation record of \"childList\" for target parent with addedNodes nodes, \r\n    // removedNodes removedNodes, nextSibling reference child, and previousSibling previousSibling.\r\n}\r\n\r\nexport function replaceAll(node, parent) {\r\n    // https://dom.spec.whatwg.org/#concept-node-replace-all\r\n    // To replace all with a node within a parent, run these steps:\r\n\r\n    // 1. If node is not null, adopt node into parent’s node document.\r\n    if (node !== null) {\r\n        adopt(node, parent.ownerDocument);\r\n    }\r\n\r\n    // 2. Let removedNodes be parent’s children.\r\n    const removedNodes = slice(parent.childNodes);\r\n\r\n    // 3. Let addedNodes be the empty list if node is null, node’s children if node is a DocumentFragment node, and a list containing node otherwise.\r\n    const addedNodes = (node === null) ? []\r\n        : (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) ? slice(node.childNodes)\r\n            : [node];\r\n\r\n    // 4. Remove all parent’s children, in tree order, with the suppress observers flag set.\r\n    for (let i = 0; i < removedNodes.length; i++) {\r\n        remove(removedNodes[i], parent, true);\r\n    }\r\n\r\n    // 5. If node is not null, insert node into parent before null with the suppress observers flag set.\r\n    if (node !== null) {\r\n        insert(node, parent, null, true);\r\n    }\r\n\r\n    // Skip (MutationObserver)\r\n    // 6. Queue a mutation record of \"childList\" for parent with addedNodes addedNodes and removedNodes removedNodes.\r\n}\r\n\r\nexport function preRemove(child, parent) {\r\n    // https://dom.spec.whatwg.org/#concept-node-pre-remove\r\n    // To pre-remove a child from a parent, run these steps:\r\n\r\n    // 1. If child’s parent is not parent, then throw a NotFoundError.\r\n    if (child.parentNode !== parent) {\r\n        throw makeError('NotFoundError');\r\n    }\r\n\r\n    // 2. Remove child from parent.\r\n    remove(child, parent);\r\n\r\n    // 3. Return child.\r\n    return child;\r\n}\r\n\r\nexport function remove(node, parent, suppessObservers) {\r\n    // https://dom.spec.whatwg.org/#concept-node-remove\r\n    // To remove a node from a parent, with an optional suppress observers flag, run these steps:\r\n\r\n    // Skip (Range)\r\n    // 1. Let index be node’s index.\r\n    // 2. For each range whose start node is an inclusive descendant of node, set its start to (parent, index).\r\n    // 3. For each range whose end node is an inclusive descendant of node, set its end to (parent, index).\r\n    // 4. For each range whose start node is parent and start offset is greater than index, decrease its start offset by one.\r\n    // 5. For each range whose end node is parent and end offset is greater than index, decrease its end offset by one.\r\n\r\n    // Skip (NodeIterator)\r\n    // 6. For each NodeIterator object iterator whose root’s node document is node’s node document, \r\n    // run the NodeIterator pre-removing steps given node and iterator.\r\n\r\n    // Skip (MutationObserver)\r\n    // 7. Let oldPreviousSibling be node’s previous sibling.\r\n    // 8. Let oldNextSibling be node’s next sibling.\r\n\r\n    // 9. Remove node from its parent.\r\n    const childNodes = shadow(parent).childNodes;\r\n    if (childNodes) {\r\n        const nodeIndex = childNodes.indexOf(node);\r\n        childNodes.splice(nodeIndex, 1);\r\n    }\r\n    delete shadow(node).parentNode;\r\n    native.Node.removeChild.call(native.Node.parentNode.get.call(node), node);\r\n\r\n    // 10. If node is assigned, then run assign slotables for node’s assigned slot.\r\n    const assignedSlot = shadow(node).assignedSlot;\r\n    if (assignedSlot) {\r\n        assignSlotables(assignedSlot);\r\n        shadow(node).assignedSlot = null;\r\n    }\r\n\r\n    // 11. If parent is a slot whose assigned nodes is the empty list, then run signal a slot change for parent.\r\n    if (parent.localName === 'slot' && parent.assignedNodes().length === 0) {\r\n        signalASlotChange(parent);\r\n    }\r\n\r\n    // 12. If node has an inclusive descendant that is a slot, then:\r\n    let inclusiveSlotDescendants = [];\r\n    if (node.localName === 'slot') {\r\n        inclusiveSlotDescendants.push(node);\r\n    }\r\n    if (node.hasChildNodes()) {\r\n        inclusiveSlotDescendants.push(...node.querySelectorAll('slot'));\r\n    }\r\n    if (inclusiveSlotDescendants.length) {\r\n        // 1. Run assign slotables for a tree with parent’s tree.\r\n        assignSlotablesForATree(parent);\r\n        // 2. Run assign slotables for a tree with node’s tree and a \r\n        // set containing each inclusive descendant of node that is a slot.\r\n        assignSlotablesForATree(node, inclusiveSlotDescendants);\r\n    }\r\n\r\n    // Skip (other)\r\n    // 13. Run the removing steps with node and parent.\r\n\r\n    // Skip (CustomElements)\r\n    // 14. If node is custom, then enqueue a custom element callback reaction \r\n    // with node, callback name \"disconnectedCallback\", and an empty argument list.\r\n    // 15. For each shadow-including descendant descendant of node, in \r\n    // shadow-including tree order, run these substeps:\r\n\r\n    // Skip (MutationObserver)\r\n    // 16. For each inclusive ancestor inclusiveAncestor of parent, if inclusiveAncestor \r\n    // has any registered observers whose options' subtree is true, then for each such registered \r\n    // observer registered, append a transient registered observer whose observer and options are \r\n    // identical to those of registered and source which is registered to node’s list of registered observers.\r\n    // 17. If suppress observers flag is unset, queue a mutation record of \"childList\" for parent \r\n    // with removedNodes a list solely containing node, nextSibling oldNextSibling, and previousSibling \r\n    // oldPreviousSibling.\r\n}\r\n\r\nexport function clone(node, document, cloneChildren) {\r\n    // https://dom.spec.whatwg.org/#concept-node-clone\r\n    // To clone a node, with an optional document and clone children flag, run these steps:\r\n\r\n    // 1. If document is not given, let document be node’s node document.\r\n    document = document || node.ownerDocument;\r\n\r\n    // Use a shortcut here\r\n    // 2. If node is an element, then:\r\n    // 3. Otherwise, let copy be a node that implements the same interfaces \r\n    // as node, and fulfills these additional requirements, switching on node:\r\n    // 4. Set copy’s node document and document to copy, if copy is a document, \r\n    // and set copy’s node document to document otherwise.\r\n    // 5. Run any cloning steps defined for node in other applicable \r\n    // specifications and pass copy, node, document and the clone children \r\n    // flag if set, as parameters.\r\n    const copy = native.Node.cloneNode.call(node, false);\r\n\r\n    // 6. If the clone children flag is set, clone all the children of node \r\n    // and append them to copy, with document as specified and the clone \r\n    // children flag being set.\r\n    if (cloneChildren === true) {\r\n        const childNodes = slice(node.childNodes);\r\n        for (let i = 0; i < childNodes.length; i++) {\r\n            append(childNodes[i].cloneNode(true), copy);\r\n        }\r\n    }\r\n\r\n    return copy;\r\n}\r\n\r\nexport function adopt(node, document) {\r\n    // https://dom.spec.whatwg.org/#concept-node-adopt\r\n\r\n    // 1. Let oldDocument be node’s node document.\r\n    let oldDocument = node.ownerDocument;\r\n\r\n    // 2. If node’s parent is not null, remove node from its parent.\r\n    const parent = node.parentNode;\r\n    if (parent !== null) {\r\n        remove(node, parent);\r\n    }\r\n\r\n    // Skip (CustomElements, native)\r\n    // 3. If document is not the same as oldDocument, run these substeps:\r\n}"
  ]
}